import{_ as e,c as a,o as i,e as n}from"./app.a2c63123.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"过程一\\tLoading","slug":"过程一loading","link":"#过程一loading","children":[]},{"level":2,"title":"过程二\\tLinking","slug":"过程二linking","link":"#过程二linking","children":[{"level":3,"title":"验证-Verify","slug":"验证-verify","link":"#验证-verify","children":[]},{"level":3,"title":"准备-Prepare","slug":"准备-prepare","link":"#准备-prepare","children":[]},{"level":3,"title":"解析-Resolve","slug":"解析-resolve","link":"#解析-resolve","children":[]}]},{"level":2,"title":"过程三\\tInitialization","slug":"过程三initialization","link":"#过程三initialization","children":[]},{"level":2,"title":"加载器分类","slug":"加载器分类","link":"#加载器分类","children":[]},{"level":2,"title":"自定义类加载器","slug":"自定义类加载器","link":"#自定义类加载器","children":[]}],"relativePath":"serverSide/类的加载.md"}'),l={name:"serverSide/类的加载.md"},s=n(`<h2 id="过程一loading" tabindex="-1">过程一 Loading <a class="header-anchor" href="#过程一loading" aria-hidden="true">#</a></h2><p>1．通过一个类的全限定名获取定义此类的二进制字节流 2．将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3．在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><h2 id="过程二linking" tabindex="-1">过程二 Linking <a class="header-anchor" href="#过程二linking" aria-hidden="true">#</a></h2><h3 id="验证-verify" tabindex="-1">验证-Verify <a class="header-anchor" href="#验证-verify" aria-hidden="true">#</a></h3><p>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证</p><h3 id="准备-prepare" tabindex="-1">准备-Prepare <a class="header-anchor" href="#准备-prepare" aria-hidden="true">#</a></h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。 这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化; 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><h3 id="解析-resolve" tabindex="-1">解析-Resolve <a class="header-anchor" href="#解析-resolve" aria-hidden="true">#</a></h3><p>将常量池内的符号引用转换为直接引用的过程。事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h2 id="过程三initialization" tabindex="-1">过程三 Initialization <a class="header-anchor" href="#过程三initialization" aria-hidden="true">#</a></h2><p>初始化:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">初始化阶段就是执行类构造器方法&lt;clinit&gt;() 的过程</span></span>
<span class="line"><span style="color:#A6ACCD;">此方法不需定义，是javac编译器自动收集类中的所有类静态变量的赋值动作和静态代码块中的语句合并而来。 I</span></span>
<span class="line"><span style="color:#A6ACCD;">构造器方法中指令按语句在源文件中出现的顺序执行。</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;clinit&gt;()不同于类的构造器。(关联: 构造器是虚拟机视角下的&lt;init&gt;())若该类具有父类，JVM会保证子类的&lt;clinit&gt;() 执行前，父类的&lt;clinit&gt;()已经执行完毕。</span></span>
<span class="line"><span style="color:#A6ACCD;">虚拟机必须保证一个类的&lt;clinit&gt;() 方法在多线程下被同步加锁</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="加载器分类" tabindex="-1">加载器分类 <a class="header-anchor" href="#加载器分类" aria-hidden="true">#</a></h2><p>BootStrap Class Loader 引导类加载器 Extension Class Loader 扩展加载器 System Class Loader 系统加载器 自定义类加载器 <img src="https://pic.imgdb.cn/item/63e750664757feff336f52e3.png" alt=""></p><h2 id="自定义类加载器" tabindex="-1">自定义类加载器 <a class="header-anchor" href="#自定义类加载器" aria-hidden="true">#</a></h2><p>为什么要自定义？ 隔离记载类，修改加载方式，扩展加载源，防止源码泄露 如何自定义？ 1.可通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器 2.若没有复杂要求则可以直接继承URLClassLoader类，就可以避免自己重写findClass()方法及获取字节码流的方式。</p>`,16),t=[s];function r(d,o,c,p,h,g){return i(),a("div",null,t)}const v=e(l,[["render",r]]);export{_ as __pageData,v as default};
